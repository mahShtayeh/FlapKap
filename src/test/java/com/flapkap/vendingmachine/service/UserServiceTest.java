package com.flapkap.vendingmachine.service;

import com.flapkap.vendingmachine.dto.UserDTO;
import com.flapkap.vendingmachine.mapper.UserMapper;
import com.flapkap.vendingmachine.model.User;
import com.flapkap.vendingmachine.model.UserRole;
import com.flapkap.vendingmachine.repository.UserRepository;
import com.flapkap.vendingmachine.service.impl.UserServiceImpl;
import lombok.NoArgsConstructor;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.math.BigDecimal;
import java.util.UUID;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Test class for the {@link UserServiceImpl} implementation.
 * This class verifies the correct behavior of the {@link UserServiceImpl} methods
 * and ensures that the business logic operates as expected.
 * It uses Mockito annotations for mocking dependencies and JUnit 5 for testing.
 *
 * @author Mahmoud Shtayeh
 */
@NoArgsConstructor
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    /**
     * A mocked instance of {@link UserRepository} used for testing purposes.
     * This mock is intended to simulate the behavior of the real {@link UserRepository}
     * interface, allowing tests to verify the integration points and logic of the
     * service layer without reliance on the actual persistence layer.
     */
    @Mock
    private UserRepository userRepository;

    /**
     * A mocked instance of {@link UserMapper} used for testing purposes.
     */
    @Mock
    private UserMapper userMapper;

    /**
     * Mock implementation of the {@link PasswordEncoder} interface used for
     * encoding passwords during unit tests.
     */
    @Mock
    private PasswordEncoder passwordEncoder;

    /**
     * An instance of {@link UserServiceImpl} injected into the test class to perform
     * unit tests for the service layer. It is initialized and managed by Mockito's
     *
     * @InjectMocks annotation, which automatically injects the required mocked dependencies
     * (e.g., {@link UserRepository}, {@link UserMapper}) into the service implementation.
     */
    @InjectMocks
    private UserServiceImpl userService;

    /**
     * A unique identifier used to represent a specific user throughout the test cases.
     * It is initialized with a randomly generated UUID value to mimic the behavior of unique
     * user identification in a real-world scenario. This constant is primarily used to
     * validate methods that involve user identity management, such as registration or retrieval.
     */
    private static final UUID USER_ID = UUID.randomUUID();

    /**
     * Represents the default email address used in test cases for the {@link UserServiceTest} class.
     * This email mimics a user's email attribute and is used to validate scenarios such as
     * user registration or data mapping.
     */
    private static final String USERNAME = "jack.smith@flapkap.com";

    /**
     * Represents a static initial test balance value for use in test cases.
     * This balance is used to initialize or validate functionality related
     * to monetary computations or operations involving user deposits within
     * the system.
     */
    private static final BigDecimal BALANCE = BigDecimal.valueOf(1000.00);

    /**
     * A constant representing a pre-defined password value, likely used for testing purposes
     * within the {@code UserServiceTest}. This password is stored as a hashed string,
     * emphasizing the importance of security when dealing with sensitive information.
     * SHA256 Hashed value of: <PASSWORD>.
     */
    private static final String HASHED_PASSWORD = "73e460e77a656f17dfe522a7571e2671ead0abf36c4184ef3dfba2d4affe8702";

    /**
     * A constant representing an encrypted password value used for testing or internal validation purposes.
     * This value is intended to simulate an encoded password similar to those generated by the application's
     * password encoding mechanism, such as BCrypt hashing, for validating password security features.
     */
    private static final String ENCRYPTED_PASSWORD = "$2a$12$xJZv6T6OrSg4KUYAYOjISuL/9bh4ZhcEFYEIqMAzHKLXsf2MZL15G";

    /**
     * A predefined static instance of {@link UserDTO} used for testing purposes in the {@code UserServiceTest} class.
     * This instance is built using the {@link UserDTO#builder()} method and initialized with specific
     * values for the user's first name, last name, email, and password.
     */
    private static final UserDTO BUYER_DTO = UserDTO.builder()
            .username(USERNAME)
            .password(HASHED_PASSWORD)
            .deposit(BALANCE)
            .role(UserRole.BUYER)
            .build();

    /**
     * A static, immutable instance of the {@link User} entity used for transient operations
     * in testing within the {@link UserServiceTest} class. This instance is pre-configured with
     * predefined values for `firstName`, `lastName`, `email`, and `password` fields,
     * allowing consistent and reusable test execution.
     */
    private static final User TRANSIENT_BUYER = User.builder()
            .username(USERNAME)
            .password(ENCRYPTED_PASSWORD)
            .deposit(BALANCE)
            .role(UserRole.BUYER)
            .build();

    /**
     * A predefined instance of the {@link User} class for testing purposes in the `UserServiceTest` class.
     * This object is constructed using the builder pattern and represents a fully initialized user entity
     * with the specified test data such as `USER_ID`, `FIRST_NAME`, `LAST_NAME`, `EMAIL`, and `PASSWORD`.
     */
    private static final User BUYER = User.builder()
            .id(USER_ID)
            .username(USERNAME)
            .password(ENCRYPTED_PASSWORD)
            .deposit(BALANCE)
            .role(UserRole.BUYER)
            .build();

    /**
     * Validates the functionality of the `register` method in the `UserService` class
     * when registering a valid user by ensuring the proper interactions with `userMapper`
     * and `userRepository` and verifying the expected user ID is returned.
     */
    @Test
    void registerBuyer_withValidDetails_shouldReturnsUserId() {
        when(passwordEncoder.encode(HASHED_PASSWORD)).thenReturn(ENCRYPTED_PASSWORD);
        when(userMapper.toEntity(BUYER_DTO, ENCRYPTED_PASSWORD)).thenReturn(TRANSIENT_BUYER);
        when(userRepository.save(TRANSIENT_BUYER)).thenReturn(BUYER);

        final UUID userId = userService.register(BUYER_DTO);

        verify(userMapper).toEntity(argThat(userDTO -> userDTO.equals(BUYER_DTO)),
                argThat(ENCRYPTED_PASSWORD::equals));
        verify(userRepository).save(TRANSIENT_BUYER);
        assertThat(userId).isEqualTo(USER_ID);
    }
}