package com.flapkap.vendingmachine.service;

import com.flapkap.vendingmachine.dto.ProductDTO;
import com.flapkap.vendingmachine.mapper.ProductMapper;
import com.flapkap.vendingmachine.model.Product;
import com.flapkap.vendingmachine.model.Role;
import com.flapkap.vendingmachine.model.User;
import com.flapkap.vendingmachine.repository.ProductRepository;
import com.flapkap.vendingmachine.service.impl.ProductServiceImpl;
import com.flapkap.vendingmachine.web.response.ProductResponse;
import lombok.NoArgsConstructor;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.mockito.Mockito.*;

/**
 * Unit tests for the {@link ProductServiceImpl} class.
 * This test class is designed to verify the functionality of the {@code ProductServiceImpl},
 * ensuring its methods behave as expected when interacting with mocked dependencies.
 *
 * @author Mahmoud Shtayeh
 */
@NoArgsConstructor
@ExtendWith(MockitoExtension.class)
class ProductServiceTest {
    /**
     * Mocked instance of the {@link ProductRepository} used for testing purposes.
     * This mock is used to simulate interactions with the data layer
     * when testing service-level logic in the {@code ProductServiceTest} class.
     */
    @Mock
    private ProductRepository productRepository;

    /**
     * A mocked instance of the {@link ProductMapper} interface used in the {@code ProductServiceTest} class.
     * This mock is utilized to isolate and verify the behavior of the {@code ProductService} by simulating
     * the mapping between product-related data models such as {@code ProductDTO}, {@code ProductCreationRequest},
     * and {@code Product} without relying on the actual implementation of the {@code ProductMapper}.
     */
    @Mock
    private ProductMapper productMapper;

    /**
     * Mocked instance of {@link UserService} used for testing purposes.
     * The mock setup and behavior can be specified in individual test methods
     * within the containing test class.
     */
    @Mock
    private UserService userService;

    /**
     * The {@code productService} variable is an instance of {@link ProductServiceImpl},
     * used as a mock object for testing purposes in the {@code ProductServiceTest} class.
     * It is annotated with {@code @InjectMocks} to enable the injection of mock dependencies
     * into the {@code productService} object during unit tests.
     */
    @InjectMocks
    private ProductServiceImpl productService;

    /**
     * A unique identifier representing a seller in the test context.
     * This constant is used to ensure stable and consistent identification
     * of the seller throughout the test cases in the ProductServiceTest class.
     */
    private static final UUID SELLER_ID = UUID.randomUUID();

    /**
     * A unique identifier for the product used in testing scenarios.
     * This constant is initialized with a randomly generated UUID to ensure
     * uniqueness across different test runs.
     */
    private static final UUID PRODUCT_ID = UUID.randomUUID();

    /**
     * Represents the default email address used in test cases for the {@link UserServiceTest} class.
     * This email mimics a user's email attribute and is used to validate scenarios such as
     * user registration or data mapping.
     */
    private static final String BUYER_USERNAME = "jack.smith@flapkap.com";

    /**
     * Represents a predefined username used to simulate or test the functionality
     * of a seller entity within the scope of the UserServiceTest. This value serves
     * as a static reference for scenarios where an authenticated seller's username
     * is required, ensuring consistency across test cases.
     */
    private static final String SELLER_USERNAME = "alen.martin@flapkap.com";

    /**
     * The BALANCE constant represents the initial amount of funds or capital
     * available in the system for testing purposes. It is used across multiple
     * test cases to validate business logic and ensure proper handling of
     * monetary values. The value is immutable and cannot be modified at runtime.
     */
    private static final Integer BALANCE = 1000;

    /**
     * A constant representing an encrypted password value used for testing or internal validation purposes.
     * This value is intended to simulate an encoded password similar to those generated by the application's
     * password encoding mechanism, such as BCrypt hashing, for validating password security features.
     */
    private static final String ENCRYPTED_PASSWORD = "$2a$12$xJZv6T6OrSg4KUYAYOjISuL/9bh4ZhcEFYEIqMAzHKLXsf2MZL15G";

    /**
     * The constant representing the name of a product used in tests.
     * This is a static and immutable value initialized to "Laptop".
     * Primarily used within test cases to avoid hardcoding
     * repeated product name strings, ensuring consistency and reusability.
     */
    private static final String PRODUCT_NAME = "Laptop";

    /**
     * Represents the fixed quantity of the product used within the test cases
     * in the {@code ProductServiceTest} class. This constant value is utilized
     * to validate functionality related to product amounts during test execution.
     */
    private static final Integer PRODUCT_AMOUNT = 200;

    /**
     * A constant representing the updated amount value for a product during testing scenarios.
     * This value is used to simulate changes to the product's amount in the context of unit tests,
     * particularly within the `updateProduct_withValidDetails_shouldReturnUpdatedProduct` test method
     * in the `ProductServiceTest` class.
     */
    private static final Integer UPDATE_PRODUCT_AMOUNT = 300;

    /**
     * Represents the cost of a product in the context of product-related tests.
     * This is a constant value used as a reference for testing scenarios.
     */
    private static final Integer PRODUCT_COST = 1500;

    /**
     * Constant representing the product description for testing purposes.
     * Used to simulate a product with specific attributes during test execution.
     * The value encapsulates concise details about the product.
     */
    private static final String PRODUCT_DESCRIPTION = "Cori9, Ram 16GB";

    /**
     * A static and final instance of {@code ProductDTO} pre-configured with test data.
     * This object is mainly used for validating and testing purposes in the {@code ProductServiceTest} class.
     */
    private static final ProductDTO PRODUCT_DTO = ProductDTO.builder()
            .name(PRODUCT_NAME)
            .amount(PRODUCT_AMOUNT)
            .cost(PRODUCT_COST)
            .description(PRODUCT_DESCRIPTION)
            .sellerId(SELLER_ID)
            .build();

    /**
     * A static and final instance of {@code ProductDTO} pre-configured with test data.
     * This object is mainly used for validating and testing purposes in the {@code ProductServiceTest} class.
     */
    private static final ProductDTO UPDATE_PRODUCT_DTO = ProductDTO.builder()
            .amount(UPDATE_PRODUCT_AMOUNT)
            .build();

    /**
     * Represents a predefined static instance of the {@link User} class used within the test context.
     * The `SELLER` variable is configured with specific attributes for test scenarios related to
     * operations involving a user with the role of `SELLER`.
     */
    private static final User SELLER = User.builder()
            .id(SELLER_ID)
            .username(SELLER_USERNAME)
            .password(ENCRYPTED_PASSWORD)
            .deposit(BALANCE)
            .role(Role.SELLER)
            .enabled(true)
            .build();

    /**
     * A static, immutable instance of the {@link Product} class intended to represent
     * a transient or temporary product configuration in test scenarios.
     * It is a final constant to ensure its state is not modified during execution.
     */
    private static final Product TRANSIENT_PRODUCT = Product.builder()
            .name(PRODUCT_NAME)
            .amount(PRODUCT_AMOUNT)
            .cost(PRODUCT_COST)
            .description(PRODUCT_DESCRIPTION)
            .seller(SELLER)
            .build();

    /**
     * A static, final instance of the Product entity used for testing purposes.
     * This product is constructed using the Product builder pattern, with defined
     * attributes such as ID, name, amount, cost, description, and seller.
     * <p>
     * The attributes are initialized using constants or predefined data, ensuring
     * consistency and immutability throughout the test lifecycle.
     */
    private static final Product PRODUCT = Product.builder()
            .id(PRODUCT_ID)
            .name(PRODUCT_NAME)
            .amount(PRODUCT_AMOUNT)
            .cost(PRODUCT_COST)
            .description(PRODUCT_DESCRIPTION)
            .seller(SELLER)
            .build();

    /**
     * A static and immutable reference to a pre-configured instance of {@link ProductResponse}.
     * This instance is built using the {@link ProductResponse#builder()} method, and it contains
     * predefined details such as product ID, name, available amount, cost, and description.
     * It is primarily used in test scenarios within {@code ProductServiceTest} to validate
     * product-related functionalities and outputs.
     */
    private static final ProductResponse PRODUCT_RESPONSE = ProductResponse.builder()
            .id(PRODUCT_ID)
            .name(PRODUCT_NAME)
            .amount(PRODUCT_AMOUNT)
            .cost(PRODUCT_COST)
            .description(PRODUCT_DESCRIPTION)
            .build();

    /**
     * A static, pre-constructed instance of {@link ProductResponse} used to represent
     * the state of a product after a successful update operation.
     * This constant is commonly used in test methods to verify the correctness of
     * the product update functionality, ensuring that the updated product details match
     * the expected values.
     */
    private static final ProductResponse UPDATE_PRODUCT_RESPONSE = ProductResponse.builder()
            .id(PRODUCT_ID)
            .name(PRODUCT_NAME)
            .amount(UPDATE_PRODUCT_AMOUNT)
            .cost(PRODUCT_COST)
            .description(PRODUCT_DESCRIPTION)
            .build();

    /**
     * Tests the successful creation of a product with valid details.
     * This test verifies that when a valid `ProductDTO` is provided, the `create` method
     * in the `ProductService` correctly maps it to a `Product` entity, associates it with
     * the corresponding seller, and persists it in the repository. It asserts that the ID
     * returned by the service matches the expected product ID.
     */
    @Test
    void createProduct_withValidDetails_shouldReturnProductId() {
        when(userService.read(SELLER_ID)).thenReturn(SELLER);
        when(productMapper.toEntity(PRODUCT_DTO, SELLER)).thenReturn(TRANSIENT_PRODUCT);
        when(productRepository.save(TRANSIENT_PRODUCT)).thenReturn(PRODUCT);

        final UUID productId = productService.create(PRODUCT_DTO);

        assertThat(productId).isEqualTo(PRODUCT_ID);
    }

    /**
     * Tests the functionality of retrieving all boughtProducts from the `ProductService`.
     * The test ensures that:
     * - The returned list is not null.
     * - The size of the returned list matches the expected number of boughtProducts.
     * - The contents of the returned list match the expected `ProductResponse` objects.
     */
    @Test
    void readAllProducts_shouldReturnListOfProducts() {
        when(productRepository.findAll()).thenReturn(List.of(PRODUCT));
        when(productMapper.toResponseList(List.of(PRODUCT))).thenReturn(List.of(PRODUCT_RESPONSE));

        final List<ProductResponse> productResponseList = productService.readAll();

        assertThat(productResponseList).isNotNull();
        assertThat(productResponseList.size()).isEqualTo(1);
        assertThat(productResponseList).isEqualTo(List.of(PRODUCT_RESPONSE));
    }

    /**
     * Tests the functionality of updating an existing product with valid details in the `ProductService`.
     * This test ensures that:
     * - The product is found in the repository by its ID.
     * - The `ProductMapper.updateEntity` method is invoked to update the product entity with the new details.
     * - The updated product is correctly mapped to a `ProductResponse` object using the `ProductMapper.toResponse` method.
     * - The `ProductService.update` method returns a response that matches the expected updated product details.
     */
    @Test
    void updateProduct_withValidDetails_shouldReturnUpdatedProduct() {
        when(productRepository.findById(PRODUCT_ID)).thenReturn(Optional.of(PRODUCT));
        when(productMapper.toResponse(PRODUCT)).thenReturn(UPDATE_PRODUCT_RESPONSE);
        doAnswer(invocation -> {
            final ProductDTO source = invocation.getArgument(0);
            final Product target = invocation.getArgument(1);
            target.setAmount(source.amount());
            return null;
        }).when(productMapper).updateEntity(UPDATE_PRODUCT_DTO, PRODUCT);

        final ProductResponse updateResponse = productService.update(PRODUCT_ID, UPDATE_PRODUCT_DTO, SELLER_ID);

        assertThat(updateResponse).isNotNull();
        assertThat(updateResponse).isEqualTo(UPDATE_PRODUCT_RESPONSE);
        assertThat(updateResponse.amount()).isEqualTo(UPDATE_PRODUCT_AMOUNT);
        verify(productMapper).toResponse(argThat(product -> product.getAmount().equals(UPDATE_PRODUCT_AMOUNT)));
    }

    /**
     * Tests the functionality of deleting a product in the ProductService.
     * This test verifies that:
     * - The product is retrieved from the repository using its unique identifier.
     * - The retrieved product is associated with the correct seller.
     * - The `delete` method of the `productRepository` is invoked to delete the product.
     */
    @Test
    void deleteProduct_shouldDeleteProduct() {
        when(productRepository.findById(PRODUCT_ID)).thenReturn(Optional.of(PRODUCT));

        productService.delete(PRODUCT_ID, SELLER_ID);

        verify(productRepository).delete(PRODUCT);
    }
}